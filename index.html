<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Screenshot Analyzer</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: #f8f9fa;
        margin: 0;
        padding: 2rem;
        min-height: 100vh;
      }

      .container {
        max-width: 1000px;
        margin: 0 auto;
        background: white;
        padding: 2rem;
        border-radius: 12px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
      }

      .upload-section {
        border: 2px dashed #e0e0e0;
        border-radius: 8px;
        padding: 2rem;
        text-align: center;
        margin-bottom: 2rem;
        transition: border-color 0.2s;
      }

      input[type="file"] {
        display: none;
      }

      .custom-upload {
        background: #007bff;
        color: white;
        padding: 0.75rem 1.5rem;
        border-radius: 6px;
        cursor: pointer;
        transition: background 0.2s;
        display: inline-block;
      }

      .custom-upload:hover {
        background: #0056b3;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 2rem;
      }

      th,
      td {
        padding: 12px;
        text-align: left;
        border-bottom: 1px solid #e0e0e0;
      }

      th {
        background-color: #f8f9fa;
        font-weight: 500;
      }

      .button-group {
        display: flex;
        justify-content: space-between;
        margin-top: 1rem;
      }

      .download-btn,
      .clear-btn {
        padding: 0.75rem 1.5rem;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: background 0.2s;
        color: white;
      }

      .download-btn {
        background: #28a745;
      }

      .download-btn:hover {
        background: #218838;
      }

      .clear-btn {
        background: #dc3545;
      }

      .clear-btn:hover {
        background: #c82333;
      }

      .loading {
        display: none;
        margin: 1rem 0;
        color: #6c757d;
      }

      .status-log {
        margin-top: 1rem;
        background-color: #f8f9fa;
        border: 1px solid #e0e0e0;
        border-radius: 6px;
        padding: 1rem;
        font-family: monospace;
        max-height: 200px;
        overflow-y: auto;
        display: none;
      }

      .status-log pre {
        margin: 0;
        white-space: pre-wrap;
        word-break: break-all;
      }

      .debug-toggle {
        margin-top: 1rem;
        font-size: 0.85rem;
        color: #6c757d;
        cursor: pointer;
      }

      .debug-toggle:hover {
        text-decoration: underline;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Screenshot Analyzer</h1>

      <div class="upload-section">
        <input type="file" id="fileInput" accept="image/*" multiple />

        <label for="fileInput" class="custom-upload"> Upload Screenshot </label>
        <p style="margin-top: 1rem; color: #6c757d">(PNG, JPG supported)</p>
      </div>

      <div class="button-group">
        <button class="clear-btn" id="clearBtn">Clear All</button>
        <button class="download-btn" id="downloadBtn">Download CSV</button>
      </div>

      <table>
        <thead>
          <tr>
            <th>Name</th>
            <th>Company</th>
            <th>Role</th>
            <th>Credentials</th>
          </tr>
        </thead>
        <tbody id="tableBody">
          <!-- Rows will be added dynamically -->
        </tbody>
      </table>

      <div class="loading" id="loading">Analyzing...</div>

      <div class="debug-toggle" id="debugToggle">Show Debug Console</div>
      <div class="status-log" id="statusLog">
        <pre id="statusText"></pre>
      </div>
    </div>

    <script>
      // Modified script section for better performance and user feedback
      // Add this to replace your existing script

      let entries = [];
      const DB_NAME = "screenshotAnalyzerDB";
      const STORE_NAME = "entries";

      // Debug logging function
      function logStatus(message, isError = false) {
        const statusText = document.getElementById("statusText");
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = `[${timestamp}] ${
          isError ? "❌ ERROR: " : "✓ "
        } ${message}`;
        statusText.innerHTML += logEntry + "\n";
        statusText.scrollTop = statusText.scrollHeight;
        console.log(logEntry);

        // Show the log if it's an error
        if (isError) {
          document.getElementById("statusLog").style.display = "block";
          document.getElementById("debugToggle").textContent =
            "Hide Debug Console";
        }
      }
      async function generateSequentialFilename(db) {
        const today = new Date();
        const dateString = today
          .toLocaleDateString("en-GB", {
            day: "2-digit",
            month: "short",
            year: "numeric",
          })
          .replace(/ /g, "");

        // Get the next sequence number for today
        const sequenceNumber = (await getTodayFileCount(db)) + 1;

        // Store the new count
        await updateTodayFileCount(db, sequenceNumber);

        // Format: 13Mar2025-1
        return `${dateString}-${sequenceNumber}`;
      }

      // Function to get today's file count from storage
      async function getTodayFileCount(db) {
        const today = new Date().toDateString();

        return new Promise((resolve, reject) => {
          if (db) {
            // Use IndexedDB
            try {
              const transaction = db.transaction(["fileCounters"], "readonly");
              const store = transaction.objectStore("fileCounters");
              const request = store.get(today);

              request.onsuccess = () => {
                const result = request.result;
                resolve(result ? result.count : 0);
              };

              request.onerror = (event) => {
                console.error(
                  "Error fetching file counter:",
                  event.target.error
                );
                resolve(0);
              };
            } catch (error) {
              // Store may not exist yet
              resolve(0);
            }
          } else {
            // Use localStorage as fallback
            const counterKey = `screenshotAnalyzer_fileCounter_${today}`;
            const count = localStorage.getItem(counterKey);
            resolve(count ? parseInt(count, 10) : 0);
          }
        });
      }

      // Function to update today's file count in storage
      async function updateTodayFileCount(db, newCount) {
        const today = new Date().toDateString();

        if (db) {
          // Ensure the store exists
          if (!db.objectStoreNames.contains("fileCounters")) {
            // Need to close and reopen the DB to create a new store
            db.close();
            const request = indexedDB.open(DB_NAME, 2);

            request.onupgradeneeded = (event) => {
              const db = event.target.result;
              if (!db.objectStoreNames.contains("fileCounters")) {
                db.createObjectStore("fileCounters", { keyPath: "date" });
              }
            };

            request.onsuccess = (event) => {
              const newDb = event.target.result;
              const transaction = newDb.transaction(
                ["fileCounters"],
                "readwrite"
              );
              const store = transaction.objectStore("fileCounters");
              store.put({ date: today, count: newCount });
              logStatus(`Updated file counter to ${newCount}`);
            };

            return;
          }

          // Store exists, update the counter
          const transaction = db.transaction(["fileCounters"], "readwrite");
          const store = transaction.objectStore("fileCounters");
          store.put({ date: today, count: newCount });
          logStatus(`Updated file counter to ${newCount}`);
        } else {
          // Use localStorage as fallback
          const counterKey = `screenshotAnalyzer_fileCounter_${today}`;
          localStorage.setItem(counterKey, newCount.toString());
          logStatus(`Updated file counter to ${newCount} (localStorage)`);
        }
      }

      // Initialize fileCounters store during DB initialization
      // Modify your existing initDB function to include this:
      function initDB() {
        return new Promise((resolve, reject) => {
          if (!window.indexedDB) {
            logStatus(
              "Your browser doesn't support IndexedDB. Using local storage instead."
            );
            resolve(null);
            return;
          }

          const request = indexedDB.open(DB_NAME, 2); // Increased version number

          request.onerror = (event) => {
            logStatus("IndexedDB error: " + event.target.error, true);
            resolve(null);
          };

          request.onupgradeneeded = (event) => {
            const db = event.target.result;

            // Create entries store if it doesn't exist
            if (!db.objectStoreNames.contains(STORE_NAME)) {
              db.createObjectStore(STORE_NAME, {
                keyPath: "id",
                autoIncrement: true,
              });
            }

            // Create fileCounters store if it doesn't exist
            if (!db.objectStoreNames.contains("fileCounters")) {
              db.createObjectStore("fileCounters", { keyPath: "date" });
            }
          };

          request.onsuccess = (event) => {
            logStatus("Database initialized successfully");
            resolve(event.target.result);
          };
        });
      }

      // Save entries to storage
      async function saveEntries(db) {
        if (db) {
          // Use IndexedDB
          const transaction = db.transaction([STORE_NAME], "readwrite");
          const store = transaction.objectStore(STORE_NAME);

          // Clear existing entries
          store.clear();

          // Add all current entries
          entries.forEach((entry) => {
            store.add(entry);
          });
          logStatus(`Saved ${entries.length} entries to IndexedDB`);
        } else {
          // Use localStorage as fallback
          localStorage.setItem(
            "screenshotAnalyzerEntries",
            JSON.stringify(entries)
          );
          logStatus(`Saved ${entries.length} entries to localStorage`);
        }
      }

      // Load entries from storage
      async function loadEntries(db) {
        return new Promise((resolve, reject) => {
          if (db) {
            // Use IndexedDB
            const transaction = db.transaction([STORE_NAME], "readonly");
            const store = transaction.objectStore(STORE_NAME);
            const request = store.getAll();

            request.onsuccess = () => {
              logStatus(
                `Loaded ${
                  request.result ? request.result.length : 0
                } entries from IndexedDB`
              );
              resolve(request.result || []);
            };

            request.onerror = (event) => {
              logStatus("Error loading entries: " + event.target.error, true);
              resolve([]);
            };
          } else {
            // Use localStorage as fallback
            const savedEntries = localStorage.getItem(
              "screenshotAnalyzerEntries"
            );
            const parsed = savedEntries ? JSON.parse(savedEntries) : [];
            logStatus(`Loaded ${parsed.length} entries from localStorage`);
            resolve(parsed);
          }
        });
      }

      // Parse the AI response for multiple people
      function parseMultiplePersons(text) {
        logStatus("Parsing AI response");
        // Split by double newlines to separate different people
        const personBlocks = text.split(/\n\s*\n/);
        logStatus(`Found ${personBlocks.length} person blocks in response`);

        const results = personBlocks
          .map((block) => {
            // Parse individual person data
            const result = block.split("\n").reduce((acc, line) => {
              if (line.includes(": ")) {
                const [key, value] = line.split(": ").map((s) => s.trim());
                acc[key.toLowerCase()] = value;
              }
              return acc;
            }, {});

            // Add timestamp for sorting
            return {
              name: result.name || "N/A",
              company: result.company || "N/A",
              role: result.role || "N/A",
              credentials: result.credentials || "N/A",
              timestamp: new Date().toISOString(),
            };
          })
          .filter(
            (person) => person.name !== "N/A" || person.company !== "N/A"
          );

        logStatus(
          `Successfully parsed ${results.length} people from the response`
        );
        return results;
      }

      // Update the table with entries
      function updateTable() {
        const tableBody = document.getElementById("tableBody");
        tableBody.innerHTML = entries
          .map(
            (entry, index) => `
        <tr id="entry-${index}">
          <td>${entry.name}</td>
          <td>${entry.company}</td>
          <td>${entry.role}</td>
          <td>${entry.credentials}</td>
        </tr>
      `
          )
          .join("");
        logStatus(`Updated table with ${entries.length} entries`);
      }

      // Process a single image file and update UI in real time
      async function processImageFile(file, db) {
        const fileId = `file-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
        logStatus(`Processing file: ${file.name} (ID: ${fileId})`);

        // Add a placeholder row to the table
        const placeholderEntry = {
          name: `Analyzing ${file.name}...`,
          company: "In progress",
          role: "-",
          credentials: "-",
          timestamp: new Date().toISOString(),
          isPlaceholder: true,
          fileId: fileId,
        };

        entries.push(placeholderEntry);
        updateTable();

        try {
          // Convert image to base64
          const base64 = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => resolve(reader.result);
            reader.onerror = (error) => reject(error);
          });

          logStatus(`Image ${fileId} converted to base64`);
          logStatus(`Sending request to serverless function for ${fileId}`);

          // Call your Netlify Function
          const response = await fetch("/.netlify/functions/analyze-image", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              imageBase64: base64,
              filename: file.name,
            }),
          });

          logStatus(`API response status for ${fileId}: ${response.status}`);

          if (!response.ok) {
            const errorText = await response.text();
            logStatus(`API Error Response for ${fileId}: ${errorText}`, true);
            throw new Error(
              `Server Error: ${response.status} ${response.statusText}`
            );
          }

          const data = await response.json();
          logStatus(`Successfully received API response for ${fileId}`);

          if (data.error) {
            throw new Error(`API Error: ${data.error}`);
          }

          const analysis = data.text;
          logStatus(
            `Received analysis text for ${fileId}: ${analysis.substring(
              0,
              50
            )}...`
          );

          // Parse multiple people from the response
          const newEntries = parseMultiplePersons(analysis);
          logStatus(`Extracted ${newEntries.length} people from ${fileId}`);

          // Remove the placeholder
          entries = entries.filter((entry) => entry.fileId !== fileId);

          // Add the new entries
          entries = [...entries, ...newEntries];

          // Update table and save to storage
          updateTable();
          await saveEntries(db);

          return newEntries.length;
        } catch (error) {
          logStatus(
            `Error processing file ${file.name} (${fileId}): ${error.message}`,
            true
          );

          // Remove the placeholder entry
          entries = entries.filter((entry) => entry.fileId !== fileId);
          updateTable();

          // Add an error entry
          const errorEntry = {
            name: `Failed: ${file.name}`,
            company: "Error",
            role:
              error.message.substring(0, 30) +
              (error.message.length > 30 ? "..." : ""),
            credentials: "-",
            timestamp: new Date().toISOString(),
            isError: true,
          };

          entries.push(errorEntry);
          updateTable();
          await saveEntries(db);

          return 0;
        }
      }

      // Process multiple files with limited concurrency
      async function processFiles(files, db) {
        const concurrencyLimit = 3; // Process 3 files at a time
        const fileArray = Array.from(files);
        const total = fileArray.length;
        const loading = document.getElementById("loading");

        loading.textContent = `Analyzing 0/${total} files...`;
        loading.style.display = "block";

        let completed = 0;
        let totalEntries = 0;

        // Process files in batches
        for (let i = 0; i < fileArray.length; i += concurrencyLimit) {
          const batch = fileArray.slice(i, i + concurrencyLimit);
          const results = await Promise.all(
            batch.map((file) => processImageFile(file, db))
          );

          completed += batch.length;
          totalEntries += results.reduce((sum, count) => sum + count, 0);
          loading.textContent = `Analyzing ${completed}/${total} files...`;
        }

        loading.style.display = "none";
        logStatus(
          `Completed processing ${completed} files, extracted ${totalEntries} entries`
        );
      }

      // Modify the downloadCSV function to use the sequential filename
      async function downloadCSV() {
        // Filter out placeholder and error entries
        const dataEntries = entries.filter(
          (entry) => !entry.isPlaceholder && !entry.isError
        );

        const headers = ["Name", "Company", "Role", "Credentials"];
        const csvContent = [
          headers.join(","),
          ...dataEntries.map((entry) =>
            [
              `"${entry.name.replace(/"/g, '""')}"`,
              `"${entry.company.replace(/"/g, '""')}"`,
              `"${entry.role.replace(/"/g, '""')}"`,
              `"${entry.credentials.replace(/"/g, '""')}"`,
            ].join(",")
          ),
        ].join("\n");

        const blob = new Blob([csvContent], {
          type: "text/csv;charset=utf-8;",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.setAttribute("href", url);

        // Generate sequential filename
        const fileName = await generateSequentialFilename(window.appDB);
        link.setAttribute("download", `${fileName}.csv`);

        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        logStatus(`Downloaded CSV file as ${fileName}.csv`);
      }

      async function init() {
        logStatus("Initializing application");
        const db = await initDB();
        window.appDB = db; // Store reference globally
        entries = await loadEntries(db);
        updateTable();

        document
          .getElementById("downloadBtn")
          .addEventListener("click", downloadCSV);

        document
          .getElementById("clearBtn")
          .addEventListener("click", async () => {
            entries = [];
            updateTable();
            await saveEntries(db);
            logStatus("Cleared all entries");
          });

        // Toggle debug console
        document.getElementById("debugToggle").addEventListener("click", () => {
          const statusLog = document.getElementById("statusLog");
          const debugToggle = document.getElementById("debugToggle");
          if (statusLog.style.display === "none" || !statusLog.style.display) {
            statusLog.style.display = "block";
            debugToggle.textContent = "Hide Debug Console";
          } else {
            statusLog.style.display = "none";
            debugToggle.textContent = "Show Debug Console";
          }
        });

        document
          .getElementById("fileInput")
          .addEventListener("change", async (e) => {
            const files = e.target.files;
            if (!files.length) {
              logStatus("No files selected", true);
              return;
            }

            await processFiles(files, db);
          });

        logStatus("Application initialized successfully");
      }
      async function processBatch(files, db) {
        const batchFileName = await generateSequentialFilename(db);
        logStatus(`Starting new batch: ${batchFileName}`);

        // Process the files
        await processFiles(files, db);

        // Return the batch filename for potential use
        return batchFileName;
      }
      document
        .getElementById("fileInput")
        .addEventListener("change", async (e) => {
          const files = e.target.files;
          if (!files.length) {
            logStatus("No files selected", true);
            return;
          }

          const batchName = await processBatch(files, window.appDB);
          // You could display the batch name in the UI if desired
          // e.g., document.getElementById("currentBatch").textContent = batchName;
        });
      // Start the app when page loads
      window.addEventListener("DOMContentLoaded", init);
    </script>
  </body>
</html>
